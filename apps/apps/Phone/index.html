<!DOCTYPE html>
<html>
<script>
    function videoCallSupport() {
        return RTCPeerConnection && navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
    }

    // BEGIN DRAG/DROP
    function allowDrop(event) {
        event.preventDefault();
    }

    function drop(event) {
        event.preventDefault();
        if (videoCallSupport()) {
            callUser(event.dataTransfer.getData("text"));
        }
    }

    function handleTouchDrop(item) {
        if (videoCallSupport()) {
            callUser(item);
        }
    }

    // END DRAG/DROP

    // BEGIN WEBSOCKET

    var connection = null;

    function establishConnection() {
        if (!videoCallSupport()) {
            document.getElementById("errorMessage").style.display = "block";
            document.getElementById("controlPanel").style.visibility = "hidden";
            return;
        }

        connection = new WebSocket('ws://' + window.location.host + '/events');

        connection.onmessage = function (e) {
            var message = JSON.parse(e.data);
            if (message["action"] === "callSignalReceived") {
                var user = message["data"]["user"];
                var data = message["data"]["data"];

                if (data.hasOwnProperty("candidate")) {
                    addCandidate(data);
                }
                else if (initiatedConnection) {
                    handleConfirmationOfCall(data);
                }
                else {
                    receiveCall(user, data);
                }
            }
        };
    }

    function sendMessage(msg, recipient) {
        var json = {"action": "sendCallSignal", "data": {"user": recipient, "data": msg}};
        connection.send(JSON.stringify(json));
    }

    // END WEBSOCKET

    // BEGIN WEBRTC

    var peerConnection = initialisePeerConnection();
    var initiatedConnection = false;

    function error() {
        handleEndOfCall();
        alert("{{generalError}}");
    }

    function addCandidate(candidate) {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    }

    function callUser(user) {
        startCall(user).then(function () {
            peerConnection.createOffer().then(offer => {
                peerConnection.setLocalDescription(new RTCSessionDescription(offer)).then(function () {
                    initiatedConnection = true;
                    sendMessage(offer, user);
                }, error);
            }, error);
        }, error);
    }

    function receiveCall(user, offer) {
        startCall(user).then(function () {
            peerConnection.setRemoteDescription(new RTCSessionDescription(offer)).then(function () {
                peerConnection.createAnswer().then(answer => {
                    peerConnection.setLocalDescription(new RTCSessionDescription(answer)).then(function () {
                        sendMessage(answer, user)
                    }, error);
                }, error);
            }, error);
        }, error);
    }

    function startCall(user) {
        return navigator.mediaDevices.getUserMedia(getAudioVideoStatus()).then(stream => {
            peerConnection.oniceconnectionstatechange = function () {
                if (peerConnection.iceConnectionState == 'disconnected' || peerConnection.iceConnectionState == 'closed') {
                    stopTracks(stream);
                    handleEndOfCall();
                }
            };

            peerConnection.ontrack = function (event) {
                handleBeginningOfCall(event.streams[0], stream);
            };

            stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

            peerConnection.onicecandidate = function(evt) {
                if (evt.candidate) {
                    sendMessage(evt.candidate, user);
                }
            };
        }, error);
    }

    function initialisePeerConnection() {
        if (!videoCallSupport())
            return null;
        return new RTCPeerConnection();
    }

    function handleConfirmationOfCall(offer) {
        peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
    }

    function endCall() {
        peerConnection.close();

        // We no longer get an oniceconnectionstatechange indicating that the connection's closed, so we clean up here.
        stopTracks(document.getElementById("localVideo").srcObject);
        handleEndOfCall();
    }

    function stopTracks(stream) {
        stream.getTracks().forEach(function (track) { track.stop(); });
    }

    function getAudioVideoStatus() {
        if (isAudioOnly()) {
            return {
                audio: true
            }
        }
        else {
            return {
                audio: true, video: { facingMode: "user" }
            }
        }
    }

    function isAudioOnly() {
        return document.getElementById("audioOnly").checked;
    }

    // END WEBRTC

    function handleBeginningOfCall(stream, localStream) {
        document.getElementById("endCallButton").style.visibility = "visible";

        if (!isAudioOnly()) {
            showVideoElements();
            playVideo("remoteVideo", stream);
            playVideo("localVideo", localStream);
        }
    }

    function playVideo(elementName, stream) {
        var video = document.getElementById(elementName);
        video.srcObject = stream;
        video.play();
    }

    function handleEndOfCall() {
        document.getElementById("endCallButton").style.visibility = "hidden";
        document.getElementById("videoContainer").style.visibility = "hidden";
        peerConnection = initialisePeerConnection();
        initiatedConnection = false;
    }

    function showVideoElements() {
        //TODO Don't hardcode these dimensions
        if (parent.fullSizedScreen()) {
            setDimensionsOfRemoteVideo(640, 480);

        } else {
            setDimensionsOfRemoteVideo(285, 285);
        }
        document.getElementById("videoContainer").style.visibility = "visible";
    }

    function setDimensionsOfRemoteVideo(width, height) {
        var videoContainer = document.getElementById("videoContainer");
        videoContainer.style.width = width + "px";
        videoContainer.style.height = height + "px";

        var video = document.getElementById("remoteVideo");
        video.style.width = width + "px";
        video.style.height = height + "px";
    }
</script>

<style>
    #remoteVideo {
        top:0;
        right:0;
        position:relative;
    }

    #localVideo {
        width:100px;
        height:100px;
        z-index:999;
        position:absolute;
        bottom:0;
        right:0;
    }

    #videoContainer {
        position:relative
    }
</style>
<body ondrop="drop(event)" ondragover="allowDrop(event)" onload="establishConnection()">
<div id="errorMessage" style="display:none">{{unsupportedBrowserError}}</div>
<div id="controlPanel">
    <input type="checkbox" id="audioOnly"/><label for="audioOnly">{{audioOnly}}</label>
    <button id="endCallButton" style="visibility:hidden" onclick="endCall()">{{hangUp}}</button>
</div>

<div id="videoContainer" style="visibility:hidden">
    <video id="remoteVideo"></video>
    <video id="localVideo" muted></video>
</div>
</body>
</html>
